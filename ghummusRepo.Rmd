---
title: "GeneHummus"
author: "Visiting Bioinformaticians Program"
date: "6/15/2018"
output: 
  html_document: 
    keep_md: yes
---

### Dependencies
```{r dependencies, message=FALSE}
library(rentrez)
library(stringr)
library(dplyr)
```

### Load the R functions
```{r source}
source("hummusFunctions.R")
```


### Read Legumes taxids
Load the object `my_hummus`. It contains the vector `legumesIds` with the legumes taxids. You can download from the NCBI the taxids from your own family or species. 
```{r legumes, cache=TRUE}
file = "my_hummus.RData"
load(file)
```


### Conserved domains

Plant gene families are characterized by common protein structure. 
The structure that defines a given family can be found in literature.   

You can specify the conserved domain accession number as a query. For example, the 
three conserved domains that define the ARF gene family are: 
```{r}
arf <- c("pfam02362", "pfam06507", "pfam02309")
arf
```

Those three accessions correspond with the three ARF conserved domains:  
  
  * B3 DNA binding domain
  * Auxin response factor
  * AUX/IAA family
  
We know from literature that the last domain AUX/IAA may be/not be present. 

### SPARCLE architectures
Then, you can get the SPARCLE architectures for each conserved domain using the `getSparcleArchs` function. 
```{r echo=TRUE, warning=FALSE}
cd1 = getSparcleArchs(arf[1])
cd2 = getSparcleArchs(arf[2])
cd3 = getSparcleArchs(arf[3])
```

For example, the SPARCLE architectures for Pfam02362 are:  
`r cd1`.  
Not all those architectures link to ARF proteins. But the architecture ids for the ARF proteins will be definitely among any of them. 

### SPARCLE labels
Thus, next step, is to identify the architecture ids corresponding to ARF proteins. For this, the SPARCLE labels come in handy. We do not need to get all the labels for each architecture ids. We just need those labels that could be present in the ARF proteins. So, we can filter by any word that we know will be present in the ARF family. For example, we know that a given ARF protein at least contain the domain "B3_DNA".

```{r}
getSparcleLabels(cd1, "B3_DNA")
```

We can run the `getSparcleLabels` function on the other two architectures (Pfam06507, Pfam02309). After examination of the labels, based on the number of domains (>=3), the only architecture ids making sense for the ARF are: 
```{r}
my_labelsIds <-  c(10332700, 11130507, 10332698, 10492348, 12034166, 11130489)
```

### Protein ids 
Now for each SPARCLE architecture we'll get the whole protein ids list that show that architecture. We'll start by analizing the first architecture (n = 1). 
```{r}
n = 1
sparcleArch = my_labelsIds[n]
```
To get the protein ids for the architecture id 10332700, we'll call the function `getProtlinks`:
```{r cache = TRUE}
my_protIds <- getProtlinks(sparcleArch)
```
Depending on the architecture id, the protein ids can be a long list. Because in the next step we'll interact with the [NCBI's web history](https://www.ncbi.nlm.nih.gov/books/NBK25501/) feature, we have to check the length of that list. Note that if you have a very long list of ids(>300) you may receive a 414 error.

```{r}
length(my_protIds)
```  
As we have < 300 ids, now we can call the function `extract_proteins` that has two arguments. The first one is a vector containing the protein ids; the second argument is the taxonomy ids for the species you want to identify the proteins. In this case study, the Legumes ids. The function returns only the protein ids hosted by the RefSeq database.  
Let's create an empty vector called `my_values` where we'll keep track of every ARF protein id from the Legume family.
```{r cache = TRUE}
my_values <- extract_proteins(my_protIds, legumesIds)
```

Now we check the architecture n = 2. 
```{r cache = TRUE}
n = 2
my_protIds <- getProtlinks(my_labelsIds[n])
```

```{r}
length(my_protIds)
```
Because this time we have a very long list (>>300), we need to subset the elements, so the `extract_proteins` function can work properly. For subsetting, we'll use the function `subsetIds` that takes as first argument the protein ids and as second argument the length of the subsetting. 

```{r cache = TRUE}
protIds_subset <-  subsetIds(my_protIds, 300)
length(protIds_subset)
```
Now we have a `protIds_subset` vector, which is a list containing `r length(protIds_subset)` elements. Each element of the list is made of 300 protein ids. 

Now we can call the function `extract_proteins_from_subset`, that in turn will pass the function `extract_proteins` on each of the`r length(protIds_subset)` elements. We need three arguments, the vector list, the targeted taxonomy ids and the vector cotaining the values to be updated. 


```{r cache=TRUE}
my_values = extract_proteins_from_subset(protIds_subset, legumesIds, my_values)
length(my_values)
```

Let's run the code for the architectures n=3-6. 


```{r cache = TRUE}
n = 3
my_protIds <- getProtlinks(my_labelsIds[n])
length(my_protIds)
```

Update `my_values` with the protein ids from SPARCLE architecture n=3:
```{r cache = TRUE}
my_values <- c(my_values, extract_proteins(my_protIds, legumesIds))
length(my_values)
```

```{r cache = TRUE}
n = 4
my_protIds <- getProtlinks(my_labelsIds[n])
length(my_protIds)
```

```{r cache = TRUE}
protIds_subset <-  subsetIds(my_protIds, 300)
my_values = extract_proteins_from_subset(protIds_subset, legumesIds, my_values)
length(my_values)
```

```{r}
n = 5
my_protIds <- getProtlinks(my_labelsIds[n])
length(my_protIds)
my_values <- c(my_values, extract_proteins(my_protIds, legumesIds))
length(my_values)
```

```{r}
n = 6
my_protIds <- getProtlinks(my_labelsIds[n])
length(my_protIds)
my_values <- c(my_values, extract_proteins(my_protIds, legumesIds))
length(my_values)
```

At this point we have likely identified the whole set of ARF protein ids from the Legume family. Because two given SPARCLE architectures may link to the same sequence, finally we want to check that `my_values` does not contain duplicated values. 

```{r unique vals}
my_values = unique(my_values)
length(my_values)
```

Now, we want to get the legume species and the number of proteins per species. 
```{r species, cache = TRUE}
my_values_subset <-  subsetIds(my_values, 300)
spp = extract_spp_from_subset(my_values_subset)
length(spp) == length(my_values)
```

```{r warning=FALSE}
spp_tidy = c()
for(sp in seq_along(spp)) {
  spp_tidy = c(spp_tidy, get_spp(spp[sp]))
}
sort(table(spp_tidy), decreasing = TRUE)
```